<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2021-07-07 Wed 14:29 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>PyGIZMO: Python APIs for the GIZMO Simulation</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Shuiyao (Charlie) Huang" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">PyGIZMO: Python APIs for the GIZMO Simulation</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgd927c60">1. Introduction</a></li>
<li><a href="#org1df0b71">2. Quick Start</a>
<ul>
<li><a href="#orgff95cc7">2.1. Requirements</a></li>
<li><a href="#org9adaddf">2.2. <span class="todo TODO">TODO</span> Installation</a></li>
<li><a href="#org2075a33">2.3. <span class="todo TODO">TODO</span> Examples</a>
<ul>
<li><a href="#org377840a">2.3.1. Load snapshots</a></li>
<li><a href="#org88ec7ee">2.3.2. Draw phase diagram and overplot wind particles</a></li>
<li><a href="#org3c4ce5d">2.3.3. Make a movie of a single evolving halo</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org7405623">3. Configuration</a></li>
<li><a href="#org390c8b0">4. Plotlib: Convenient APIs for Fine Tuning Figures for Journal Articles</a>
<ul>
<li><a href="#org0f60eda">4.1. MultiFrame: An easy interactive tool that manages figure layouts</a></li>
<li><a href="#org4c2a3c8">4.2. LinePlot: Interface for line-type plot.</a></li>
<li><a href="#orgb739fc6">4.3. Map2D: Customizing multi-layer 2D maps for simulations</a>
<ul>
<li><a href="#org68a1f15">4.3.1. DensityMap: Draw density field for a snapshot</a></li>
<li><a href="#orgc69c961">4.3.2. PhaseDiagram: Customizing multi-layer phase diagrams</a></li>
</ul>
</li>
<li><a href="#orgc90be58">4.4. Halo3D: Generating 3D particle layouts for galactic halos</a></li>
<li><a href="#org5af92bb">4.5. Class diagram</a></li>
</ul>
</li>
<li><a href="#org4d404cc">5. Galaxy and Halo Properties</a>
<ul>
<li><a href="#org5761526">5.1. Example: Galactic stellar mass function at multiple redshifts</a></li>
<li><a href="#org069524a">5.2. Design notes: derived tables and log files</a></li>
</ul>
</li>
<li><a href="#org7633b02">6. Merger Trees</a>
<ul>
<li><a href="#org49c8817">6.1. Halo Merger Trees</a>
<ul>
<li><a href="#orgf7ed0b6">6.1.1. Algorithm</a></li>
<li><a href="#org34c2155">6.1.2. <span class="todo TODO">TODO</span> Example</a></li>
</ul>
</li>
<li><a href="#org87de5c2">6.2. Galaxy Merger Trees</a>
<ul>
<li><a href="#orgcf22613">6.2.1. Implementation</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org8c1e2a9">7. Accretion Tracking Engine</a>
<ul>
<li><a href="#org5dcf19a">7.1. Basic Usage</a></li>
<li><a href="#org490d1a0">7.2. Algorithm</a>
<ul>
<li><a href="#org00592d6">7.2.1. Classification scheme</a></li>
<li><a href="#org9c8b0d2">7.2.2. Tracking wind component</a></li>
<li><a href="#orgc783b10">7.2.3. Particle splitting</a></li>
</ul>
</li>
<li><a href="#org429b6ca">7.3. Implementation</a>
<ul>
<li><a href="#orga9bdbed">7.3.1. Data structures and schema</a></li>
<li><a href="#orgf617e6b">7.3.2. Procedure</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org90171a9">8. Quasar Absorption Line Spectra</a></li>
<li><a href="#org722f823">9. <span class="todo TODO">TODO</span> Scalable Data Pipelines with Apache Spark</a></li>
<li><a href="#org2ef296f">10. References</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgd927c60" class="outline-2">
<h2 id="orgd927c60"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
PyGIZMO is a light-weight software that provides convenient APIs to cosmological hydrodynamical simulation outputs from the <a href="http://www.tapir.caltech.edu/~phopkins/Site/GIZMO.html">GIZMO</a> code.
</p>

<p>
The main components of PyGIZMO include a data warehouse implementation, several high-level modules for scientic analysis and modules for data visualization.
</p>

<p>
PyGIZMO implements data pipelines that extract and transform simulation data from various sources with multiple formats into a coherent data warehouse that can be managed with a clean set of APIs. The simulation data includes the raw particle data from the simulation snapshots, galaxy catalogs generated from group finders, and record files that stores the run-time information of wind particles.
</p>

<p>
In addition, PyGIZMO implements several high-level functionalities such as generating <a href="#org070ddaa">halo merger trees</a> and <a href="#orgf23a347">tracking galactic accretion</a> that involves some intensive computations and heavily relies on efficient data pipelining. In particular, PyGIZMO provides unique supports to analyzing the outputs from the <a href="https://arxiv.org/abs/2106.01511">PhEW</a> (Physically Evolved Winds) model, which is a novel sub-grid model in the GIZMO simulations that analytically propagates wind particles in the galactic halo.
</p>

<p>
Finally, PyGIZMO provides many plotting modules that enable quick inspection of the simulation data as well as making complicated figures for journal publications.
</p>

<p>
Future Works: Implement a set of APIs that interact with simulation data and <i>specexbin</i>, a C program for generating mock quasar absorption line spectra. Add modules that analyze the output spectra, e.g., fit line profiles to different ions in the spectra and obtain their physical properties such as column density, equivalent width, etc.
</p>



<div id="org5c7f184" class="figure">
<p><img src="./figures/classdiagram.png" alt="classdiagram.png" />
</p>
<p><span class="figure-number">Figure 1: </span>Class Diagram for PyGIZMO</p>
</div>
</div>
</div>

<div id="outline-container-org1df0b71" class="outline-2">
<h2 id="org1df0b71"><span class="section-number-2">2</span> Quick Start</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-orgff95cc7" class="outline-3">
<h3 id="orgff95cc7"><span class="section-number-3">2.1</span> Requirements</h3>
<div class="outline-text-3" id="text-2-1">
<p>
PyGIZMO is built and tested with the following libraries:
</p>

<ul class="org-ul">
<li>Python 3.x</li>
<li>numpy</li>
<li>scipy</li>
<li>pandas</li>
<li>h5py</li>
<li>matplotlib</li>
<li>seaborn</li>
<li>pyspark</li>
<li>tqdm (progress bar animation)</li>
</ul>
</div>
</div>

<div id="outline-container-org9adaddf" class="outline-3">
<h3 id="org9adaddf"><span class="section-number-3">2.2</span> <span class="todo TODO">TODO</span> Installation</h3>
<div class="outline-text-3" id="text-2-2">
<div class="org-src-container">
<pre class="src src-shell">git clone http://
<span style="color: #b0c4de;">cd</span> 
sudo python setup.py install
</pre>
</div>
</div>
</div>

<div id="outline-container-org2075a33" class="outline-3">
<h3 id="org2075a33"><span class="section-number-3">2.3</span> <span class="todo TODO">TODO</span> Examples</h3>
<div class="outline-text-3" id="text-2-3">
<p>
This <b>jupyter notebook</b> demonstrates several basic and advanced user cases of the program.
</p>
</div>

<div id="outline-container-org377840a" class="outline-4">
<h4 id="org377840a"><span class="section-number-4">2.3.1</span> Load snapshots</h4>
</div>

<div id="outline-container-org88ec7ee" class="outline-4">
<h4 id="org88ec7ee"><span class="section-number-4">2.3.2</span> Draw phase diagram and overplot wind particles</h4>
</div>

<div id="outline-container-org3c4ce5d" class="outline-4">
<h4 id="org3c4ce5d"><span class="section-number-4">2.3.3</span> Make a movie of a single evolving halo</h4>
</div>
</div>
</div>


<div id="outline-container-org7405623" class="outline-2">
<h2 id="org7405623"><span class="section-number-2">3</span> Configuration</h2>
<div class="outline-text-2" id="text-3">
<p>
The configuration file pygizmo.cfg (<a href="https://github.com/shuiyao/PyGIZMO/blob/main/pygizmo.cfg">sample</a>) controls many global parameters that defines and controls:
</p>
<ul class="org-ul">
<li>The general behaviors of PyGIZMO</li>
<li>The input formats and units of the simulation outputs</li>
<li>Default settings of the plotting modules, i.e., plotlib</li>
</ul>

<p>
The configuration files consists of different categories, each with a set of parameters.
</p>

<dl class="org-dl">
<dt>Paths</dt><dd>The paths that are used in I/O
<ul class="org-ul">
<li>pygizmo: Location of the PyGIZMO module.</li>
<li>data: Location for the simulation raw outputs and some massive derived tables (e.g., phewtable, inittable).</li>
<li>workdir: Location for derived and compiled results (e.g., grid data for the phase diagram, galaxy statistics), some permanent tables that are frequently loaded (e.g., progtable).</li>
<li>tmpdir: Location for 'cached' data, e.g., temporary tables, halo particle data used for plotting.</li>
<li>figure: Output location for figures.</li>
</ul></dd>

<dt>Schema</dt><dd>The schema for different source data.</dd>

<dt>Verbose</dt><dd>The numeric values for different levels of verbosity.</dd>

<dt>Units</dt><dd>The default units for length, mass, velocity and magnetic field strength. The GIZMO/GADGET tradition uses 1 kpc, 10<sup>10</sup> M<sub>solar</sub>, 1 km/s and 1 Gauss.</dd>

<dt>Cosmology</dt><dd>Cosmological parameters. Should be the same as in the simulation.</dd>

<dt>Default</dt><dd>A list of default values
<ul class="org-ul">
<li>logT_threshold: The log temperature that separates cold and hot gas.</li>
</ul></dd>

<dt>Simulation</dt><dd>Some attributes specific to each simulation
<ul class="org-ul">
<li>snapnum_reference: Defines the ascales of all simulation snapshots.</li>
<li>n_metals: Total number of elements in the Metallicity field.</li>
<li>elements: Ordered list that defines the name of elements in the Metallicity field.</li>
</ul></dd>

<dt>Ions</dt><dd>TODO. Properties of several important ion spectral lines.</dd>

<dt>Zsolar</dt><dd>Abundances of various elements in the solar atmosphere. Often used to normalize metallicity.</dd>

<dt>HDF5Field</dt><dd>Shortnames for HDF5 fields</dd>

<dt>HDF5ParticleTypes</dt><dd>The numerical value that corresponds to a specific particle type. Particles of any specific type are stored under PartType#/ in the HDF5 file. By default, 0, 1, 4, 5 correspond to gas particles, dark matter particles, star particles and black hole seed particles (if exist). In zoom-in simulations, 2, 3 usually correspond to dark matter particles at finer levels of resolutions.</dd>

<dt>Derived</dt><dd>A list of quantities that are not stored in the HDF5 files but can be derived from other HDF5 fields. For example, logT (log temperature) is a crucial gas property that needs to be derived from the U (internal energy), Ne (electron abundance) and Y (helium abundance) fields.</dd>
</dl>

<p>
API Example:
</p>
<div class="org-src-container">
<pre class="src src-python">&gt;&gt;&gt; <span style="color: #00ffff;">from</span> config <span style="color: #00ffff;">import</span> SimConfig
&gt;&gt;&gt; <span style="color: #eedd82;">cfg</span> = SimConfig(<span style="color: #ffa07a;">'/path/to/the/config/file.cfg'</span>)
&gt;&gt;&gt; cfg.sections()
[<span style="color: #ffa07a;">'DEFAULT'</span>, <span style="color: #ffa07a;">'Paths'</span>, <span style="color: #ffa07a;">'Schema'</span>, <span style="color: #ffa07a;">'Verbose'</span>, <span style="color: #ffa07a;">'Units'</span>, <span style="color: #ffa07a;">'Cosmology'</span>, <span style="color: #ffa07a;">'Default'</span>, <span style="color: #ffa07a;">'Simulation'</span>, <span style="color: #ffa07a;">'Ions'</span>, <span style="color: #ffa07a;">'Zsolar'</span>, <span style="color: #ffa07a;">'HDF5Fields'</span>, <span style="color: #ffa07a;">'HDF5ParticleTypes'</span>, <span style="color: #ffa07a;">'Derived'</span>]
&gt;&gt;&gt; cfg.keys(<span style="color: #ffa07a;">'Simulation'</span>)
[<span style="color: #ffa07a;">'snapnum_reference'</span>, <span style="color: #ffa07a;">'n_metals'</span>, <span style="color: #ffa07a;">'elements'</span>]
&gt;&gt;&gt; cfg.get(<span style="color: #ffa07a;">'Simulation'</span>, <span style="color: #ffa07a;">'elements'</span>)
<span style="color: #ffa07a;">'Z,Y,C,N,O,Ne,Mg,Si,S,Ca,Fe'</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org390c8b0" class="outline-2">
<h2 id="org390c8b0"><span class="section-number-2">4</span> Plotlib: Convenient APIs for Fine Tuning Figures for Journal Articles</h2>
<div class="outline-text-2" id="text-4">
<p>
The current module implements the following classes:
</p>
</div>

<div id="outline-container-org0f60eda" class="outline-3">
<h3 id="org0f60eda"><span class="section-number-3">4.1</span> MultiFrame: An easy interactive tool that manages figure layouts</h3>
<div class="outline-text-3" id="text-4-1">
<p>
The MultiFrame class defines the general layout of a figure through a set of parameters and APIs. One could always call the <code>sketch()</code> method to checkout the current layout of the figure, and then fine tune the parameters iteratively before adding data to the figure.
</p>

<p>
Once the layouts are finalized, one can call the <code>draw()</code> method, which returns <code>fig</code> and <code>axs</code>.
</p>

<p>
PlotLib provides two additional classes can be used to easily customize figure legends and colorbars:
</p>
<ul class="org-ul">
<li>Legend: Easily customizing multiple legends to MultiFrame</li>
<li>ColorBar: (TODO) Easily customizing multiple colorbars to MultiFrame</li>
</ul>

<p>
Here is demo for several user cases:
</p>
<div class="org-src-container">
<pre class="src src-python">I. 2 x 2, tight layout, identical panels

   +-------+-------+
   |       |       |
 y |       |       |
   |       |       |
   +-------+-------+
   |       |       |
 y |       |       |
   |       |       |
   +-------+-------+
       x       x

&gt;&gt;&gt; <span style="color: #eedd82;">frm</span> = FrameMulti(2,2,tight_layout=<span style="color: #7fffd4;">True</span>)
&gt;&gt;&gt; frm.set_xlabels(<span style="color: #ffa07a;">'x'</span>, which=<span style="color: #ffa07a;">'row'</span>)
&gt;&gt;&gt; frm.set_ylabels(<span style="color: #ffa07a;">'y'</span>, which=<span style="color: #ffa07a;">'col'</span>)

II. 2 x 2, independent panels

   +-------+    +-------+
   |       |    |       |
 y |       |  y |       |
   |       |    |       |
   +-------+    +-------+
       x            x
   +-------+    +-------+
   |       |    |       |
 y |       |  y |       |
   |       |    |       |
   +-------+    +-------+
       x            x

&gt;&gt;&gt; <span style="color: #eedd82;">frm</span> = FrameMulti(2,2,tight_layout=<span style="color: #7fffd4;">False</span>)
&gt;&gt;&gt; frm.set_param(<span style="color: #ffa07a;">'hspace'</span>, 0.25)
&gt;&gt;&gt; frm.set_xlabels(<span style="color: #ffa07a;">'x'</span>)
&gt;&gt;&gt; frm.set_ylabels(<span style="color: #ffa07a;">'y'</span>) <span style="color: #ff4500;"># </span><span style="color: #ff4500;">which = 'all' by default</span>
&gt;&gt;&gt; frm.sketch()

III. Main <span style="color: #00ffff;">and</span> side panels

    +-------+---+
    |       |   |
 y1 |       |   |
    |       |   |
    +-------+---+
 y2 |       | x
    +-------+
        x

&gt;&gt;&gt; <span style="color: #eedd82;">frm</span> = FrameMulti(2,2)
&gt;&gt;&gt; <span style="color: #eedd82;">frm._params.height_ratios</span> = [4, 1]
&gt;&gt;&gt; <span style="color: #eedd82;">frm._params.width_ratios</span> = [4, 1]
&gt;&gt;&gt; frm.set_xlabels(<span style="color: #ffa07a;">'x'</span>, which=[(1,0),(0,1)])
&gt;&gt;&gt; frm.set_ylabels(<span style="color: #ffa07a;">'y1'</span>, which=(0,0))
&gt;&gt;&gt; frm.set_ylabels(<span style="color: #ffa07a;">'y2'</span>, which=(1,0))
&gt;&gt;&gt; <span style="color: #eedd82;">frm.axisON</span>[3] = <span style="color: #7fffd4;">False</span>
&gt;&gt;&gt; frm.sketch()

IV. (2) x 3 panels

    +-------+-------+-------+
    |       |       |       |
 y1 |       |       |       |
    |       |       |       |
    |       |       |       |
    +-------+-------+-------+
 y2 |       |       |       |
    +-------+-------+-------+
       x        x       x

&gt;&gt;&gt; <span style="color: #eedd82;">frm</span> = FrameMulti(2,3,tight_layout=<span style="color: #7fffd4;">True</span>)
&gt;&gt;&gt; <span style="color: #eedd82;">frm._params.height_ratios</span> = [4, 1]
&gt;&gt;&gt; frm.set_xlabels(<span style="color: #ffa07a;">'x'</span>, which=<span style="color: #ffa07a;">'bottom'</span>)
&gt;&gt;&gt; frm.set_ylabels(<span style="color: #ffa07a;">'y1'</span>, which=(0,0))
&gt;&gt;&gt; frm.set_ylabels(<span style="color: #ffa07a;">'y2'</span>, which=(1,0))
&gt;&gt;&gt; frm.sketch()

V. 2 x 2, tight layout <span style="color: #00ffff;">with</span> legends

   +-------+-------+ 111
   |       |       | 111
 y |       |       |
   |       |       |
   +-------+-------+
   |    333|       |
 y |       |       |
   |       |       | 2222
   +-------+-------+ 2222
       x       x

&gt;&gt;&gt; <span style="color: #eedd82;">frm</span> = FrameMulti(2,2, <span style="color: #7fffd4;">True</span>)
&gt;&gt;&gt; frm.set_xlabels(<span style="color: #ffa07a;">'xlabel'</span>)
&gt;&gt;&gt; frm.set_ylabels(<span style="color: #ffa07a;">'ylabel'</span>)

&gt;&gt;&gt; <span style="color: #eedd82;">lgd1</span> = Legend()
&gt;&gt;&gt; lgd1.add_line(<span style="color: #ffa07a;">"lgd1:black line"</span>)
&gt;&gt;&gt; frm.add_legend(lgd1, which=<span style="color: #ffa07a;">"upper right"</span>, loc=<span style="color: #ffa07a;">"upper right"</span>)

&gt;&gt;&gt; <span style="color: #eedd82;">lgd2</span> = Legend()
&gt;&gt;&gt; lgd2.add_patch(<span style="color: #ffa07a;">"lgd2:red patch"</span>, fc=<span style="color: #ffa07a;">'red'</span>)
&gt;&gt;&gt; frm.add_legend(lgd2, which=<span style="color: #ffa07a;">"lower right"</span>, loc=<span style="color: #ffa07a;">"lower right"</span>)

&gt;&gt;&gt; <span style="color: #eedd82;">lgd3</span> = Legend()
&gt;&gt;&gt; lgd3.add_line(<span style="color: #ffa07a;">"lgd3:thick blue dashed line"</span>, <span style="color: #ffa07a;">"blue"</span>, <span style="color: #ffa07a;">"--"</span>, 2)
&gt;&gt;&gt; frm.add_legend(lgd3, which=<span style="color: #ffa07a;">"lower left"</span>, loc=<span style="color: #ffa07a;">"upper right"</span>)

&gt;&gt;&gt; frm.set_param(<span style="color: #ffa07a;">'right'</span>, 0.80)
&gt;&gt;&gt; frm.sketch()
</pre>
</div>
</div>
</div>

<div id="outline-container-org4c2a3c8" class="outline-3">
<h3 id="org4c2a3c8"><span class="section-number-3">4.2</span> LinePlot: Interface for line-type plot.</h3>
<div class="outline-text-3" id="text-4-2">
<p>
LinePlot provides a unified interface for making line-type plot that includes data from various sources (both models/simulations and observational/experimental data) in a single panel. A popular user case is to compare the GSMFs from many simulations to observational data in a same plot.
</p>

<p>
It relies on two external files as input:
</p>
<ul class="org-ul">
<li>A configuration file (e.g., "lineplot.cfg") that defines the default panel-level attributes (e.g., the x/y limits, labels, tick formats, fontsizes) of different types of plots.</li>
<li>A tabular file that defines the color/style schema for various models. The same schema could be used for various types of plots for consistency. Here is an example table:</li>
</ul>

<table id="org26920d5" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">model</th>
<th scope="col" class="org-left">color</th>
<th scope="col" class="org-left">style</th>
<th scope="col" class="org-right">size</th>
<th scope="col" class="org-left">label</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">l25n288-mfm</td>
<td class="org-left">red</td>
<td class="org-left">-</td>
<td class="org-right">2</td>
<td class="org-left">MFM-Hres</td>
</tr>

<tr>
<td class="org-left">l25n144-mfm</td>
<td class="org-left">red</td>
<td class="org-left">--</td>
<td class="org-right">1</td>
<td class="org-left">MFM-Lres</td>
</tr>

<tr>
<td class="org-left">l25n288-sph</td>
<td class="org-left">blue</td>
<td class="org-left">-</td>
<td class="org-right">2</td>
<td class="org-left">SPH-Hres</td>
</tr>

<tr>
<td class="org-left">l25n144-sph</td>
<td class="org-left">blue</td>
<td class="org-left">--</td>
<td class="org-right">1</td>
<td class="org-left">SPH-Lres</td>
</tr>

<tr>
<td class="org-left">baldry12</td>
<td class="org-left">black</td>
<td class="org-left">o</td>
<td class="org-right">12</td>
<td class="org-left">Baldry+12</td>
</tr>
</tbody>
</table>

<p>
Here are some of the advantages of using LinePlot
</p>
<ul class="org-ul">
<li>Maintain a consistent color/linestyle schema for each model through a report/paper.</li>
<li>Easily build and reload template layouts for various types of plots.</li>
</ul>

<p>
Currently several types (most common ones in extragalactic astronomy) of plots have implemented this interface:
</p>
<ul class="org-ul">
<li>LinePlotGSMF: Galactic stellar mass functions</li>
<li>LinePlotSMHM: Stellar mass - halo mass functions</li>
<li>LinePlotMZR: Mass-metallicity relations</li>
</ul>
</div>
</div>

<div id="outline-container-orgb739fc6" class="outline-3">
<h3 id="orgb739fc6"><span class="section-number-3">4.3</span> Map2D: Customizing multi-layer 2D maps for simulations</h3>
<div class="outline-text-3" id="text-4-3">
<p>
Map2D is an interface for two-dimensional maps (z = f(x, y)). Most common instance is a density map (2D histogram).
</p>

<p>
Currently two classes of figures have implemented Map2D:
</p>
</div>

<div id="outline-container-org68a1f15" class="outline-4">
<h4 id="org68a1f15"><span class="section-number-4">4.3.1</span> DensityMap: Draw density field for a snapshot</h4>
<div class="outline-text-4" id="text-4-3-1">
<p>
The base layer shows the mass density or temperature distribution of snapshot. The region to display can be a slice from the simulation and at a user defined resolution level. 
</p>

<p>
A few additional layers can be added to the base layer.
</p>
<dl class="org-dl">
<dt>Galactic halos</dt><dd>By default, galactic halos within a given mass range can be displayed as circles whose sizes correspond to the physical radius of the halos.</dd>
<dt>Particles</dt><dd>A layer of selected particles. Often we overplot wind particles on top of the density map to show the prevalence of galactic winds in a snapshot.</dd>
<dt>(TODO) Contour of different ions (e.g., HI, OVI)</dt><dd>Note that different ions are sensitive to different physical conditions such as density, temperature and metallicity and therefore trace different structures.</dd>
</dl>
</div>
</div>

<div id="outline-container-orgc69c961" class="outline-4">
<h4 id="orgc69c961"><span class="section-number-4">4.3.2</span> PhaseDiagram: Customizing multi-layer phase diagrams</h4>
<div class="outline-text-4" id="text-4-3-2">
<p>
The mass distribution of gas particles in the density-temperature space.
</p>

<p>
Like in a DensityMap, PhaseDiagram allows a particle layer and a ion contour layer.
</p>
</div>
</div>
</div>

<div id="outline-container-orgc90be58" class="outline-3">
<h3 id="orgc90be58"><span class="section-number-3">4.4</span> Halo3D: Generating 3D particle layouts for galactic halos</h3>
<div class="outline-text-3" id="text-4-4">
<p>
Draw an overall view of the configuration of various types of particles in a selected halo, and two additional views that zoom in on the center of the halo.
</p>

<p>
One can make a movie (<b>sample</b>) showing the evolution of the halo over time by identifying and showing its progenitors in previous snapshots.
</p>
</div>
</div>

<div id="outline-container-org5af92bb" class="outline-3">
<h3 id="org5af92bb"><span class="section-number-3">4.5</span> Class diagram</h3>
<div class="outline-text-3" id="text-4-5">

<div id="org8daa342" class="figure">
<p><img src="./figures/plotlib.png" alt="plotlib.png" />
</p>
<p><span class="figure-number">Figure 2: </span>Class Diagram for the Plotting Module</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org4d404cc" class="outline-2">
<h2 id="org4d404cc"><span class="section-number-2">5</span> Galaxy and Halo Properties</h2>
<div class="outline-text-2" id="text-5">
<p>
The <code>Analysis</code> classes provides functions that compute key diagnostic statistics and analytics for galaxy and halo properties, such as the galactic stellar mass functions (<code>Gsmf</code>), stellar mass - halo mass functions (<code>Smhm</code>), mass metallicity relation (<code>Mzr</code>), halo gas components (<code>HaloGasComponents</code>) and halo radial profiles (<code>RadialProfile</code>). The results are often saved as permanent tables in designated locations that can be used by the plotting modules for making scientific figures.
</p>
</div>

<div id="outline-container-org5761526" class="outline-3">
<h3 id="org5761526"><span class="section-number-3">5.1</span> Example: Galactic stellar mass function at multiple redshifts</h3>
<div class="outline-text-3" id="text-5-1">
<p>
The following script generates the galactic stellar mass functions at four redshifts from a simulation, saves the result to the work-dir and compares the results with observational data.
</p>

<p>
Galactic stellar mass function at z = 0,1,2,4
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #00ffff;">from</span> simulation <span style="color: #00ffff;">import</span> Simulation
<span style="color: #00ffff;">from</span> analysis <span style="color: #00ffff;">import</span> Gsmf
<span style="color: #00ffff;">from</span> plotlib <span style="color: #00ffff;">import</span> FrameMulti
<span style="color: #00ffff;">from</span> plotlib.lineplot <span style="color: #00ffff;">import</span> LinePlot, LinePlotGSMF

<span style="color: #ff4500;"># </span><span style="color: #ff4500;">Generate the GSMFs at four redshifts</span>
<span style="color: #eedd82;">gsmf</span> = Gsmf(<span style="color: #ffa07a;">"l25n144-test"</span>)
<span style="color: #eedd82;">redshifts</span> = [0.0, 1.0, 2.0, 4.0]
gsmfs.compute(z=redshifts, overwrite=<span style="color: #7fffd4;">True</span>)

<span style="color: #ff4500;"># </span><span style="color: #ff4500;">Make plot</span>
<span style="color: #eedd82;">frm</span> = FrameMulti(2, 2, tight_layout=<span style="color: #7fffd4;">True</span>) <span style="color: #ff4500;"># </span><span style="color: #ff4500;">2 x 2 share-xy</span>
frm.set_xlabels(<span style="color: #ffa07a;">'$\log(M_{gal}/M_\odot)$'</span>, loc=<span style="color: #ffa07a;">'bottom'</span>)
frm.set_ylabels(<span style="color: #ffa07a;">'$\Phi(M)dMdz$'</span>, loc=<span style="color: #ffa07a;">'left'</span>)
frm.set_xticks([10.0, 10.5, 11.0, 11.5, 12.0])
frm.set_yticks([-4., -3., -2., -1., 0.0])
frm.draw()

<span style="color: #00ffff;">for</span> i, z <span style="color: #00ffff;">in</span> <span style="color: #b0c4de;">enumerate</span>(redshifts):
  <span style="color: #eedd82;">lines</span> = LinePlotGSMF(ax=axs[i], models=<span style="color: #ffa07a;">"models.dat"</span>)
  lines.add_model(<span style="color: #ffa07a;">'l25n144-test'</span>, z=z)
  lines.draw()
</pre>
</div>

<p>
To compare the results with other simulations and observational data, replace the last section with (with a input file like <a href="#org26920d5">this one</a>):
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #eedd82;">models</span> = [<span style="color: #ffa07a;">'l25n144-test'</span>, <span style="color: #ffa07a;">'l25n288-test'</span>, <span style="color: #ffa07a;">'l25n144-final'</span>, <span style="color: #ffa07a;">'l25n288-final'</span>]
<span style="color: #eedd82;">observations</span> = [<span style="color: #ffa07a;">'baldry12'</span>, <span style="color: #ffa07a;">'tomczak14'</span>, <span style="color: #ffa07a;">'tomczak14'</span>, <span style="color: #ffa07a;">'song16'</span>]

<span style="color: #00ffff;">for</span> i, z <span style="color: #00ffff;">in</span> <span style="color: #b0c4de;">enumerate</span>(redshifts):
  <span style="color: #eedd82;">lines</span> = LinePlotGSMF(ax=axs[i], models=<span style="color: #ffa07a;">"models.dat"</span>)
  <span style="color: #00ffff;">for</span> model <span style="color: #00ffff;">in</span> models:
    lines.add_model(model, z=z)
  lines.add_data(observations[i])
  lines.draw()
</pre>
</div>
</div>
</div>

<div id="outline-container-org069524a" class="outline-3">
<h3 id="org069524a"><span class="section-number-3">5.2</span> Design notes: derived tables and log files</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Since some of the computations for derived properties of galaxy and halo properties can be expensive, PyGIZMO automatically saves the results into tabular files at designated locations and keep tracks of any expensive operation that has already been performed on a simulation basis. These results can then be loaded into other modules without having to be re-computed.
</p>

<p>
PyGIZMO implements this idea using two classes, <i>DerivedTable</i> and <i>SimLog</i>, for each simulation/model. Whenever a DerivedTable has been computed and saved, an entry is written into the SimLog with detailed information on how the table was generated (e.g., the parameters that was passed to the <code>DerivedTable.build_table() method</code>). At any time when a particular result is needed, <code>DerivedTable.load_table()</code> will check the SimLog to see if the table has already been created with the same parameters. If so, unless the keyword overwrite is set to True, the existing result will be loaded. 
</p>

<p>
The DerivedTable has two sub-classes, PermanentTable and TemporaryTable. The permanent tables are often results that are deterministic and often used, such as the galactic stellar mass functions, merger trees, and the many simulation-level inputs to the <a href="#orgf23a347">accretion tracking engine</a>. The temporary tables often have limited usage, are intermediate outputs of a long data pipeline, or depend on user defined parameters.
</p>
</div>
</div>
</div>

<div id="outline-container-org7633b02" class="outline-2">
<h2 id="org7633b02"><span class="section-number-2">6</span> Merger Trees</h2>
<div class="outline-text-2" id="text-6">
<p>
<a id="org070ddaa"></a>
</p>
</div>


<div id="outline-container-org49c8817" class="outline-3">
<h3 id="org49c8817"><span class="section-number-3">6.1</span> Halo Merger Trees</h3>
<div class="outline-text-3" id="text-6-1">

<div id="org845f36a" class="figure">
<p><img src="./figures/prog.png" alt="prog.png" />
</p>
<p><span class="figure-number">Figure 3: </span>Definitions of Relations Between Halos</p>
</div>

<p>
Halo merger trees define the relation between two halos at different time. In a simulation, a halo is uniquely determined by a pair Halo(haloId, snapnum), where haloId is the ID of the halo at a particular snapshot (snapnum). 
</p>

<p>
A halo merger tree reconstructs the assembly history of any halo from a snapshot, locating its main <i>progenitor</i> in all previous snapshots since its formation and defines the relations between all halos at a snapshot to the progenitor at the same snapshot.
</p>

<p>
The merger trees and the related properties are managed with the ProgTracker class in <code>progen.py</code>.
</p>
</div>

<div id="outline-container-orgf7ed0b6" class="outline-4">
<h4 id="orgf7ed0b6"><span class="section-number-4">6.1.1</span> Algorithm</h4>
<div class="outline-text-4" id="text-6-1-1">
<p>
First of all, in each snapshot, one finds the host halo for any halo in the snapshot. The center of a halo must reside within the virial radius of its host halo, which is more massive. The result is saved in a PermanentTable named hostmap.
</p>

<p>
The main progenitor of any halo in an earlier time is defined as the halo that contains most of its dark matter particles at that snapshot. Since the halo finder only identifies strucutres over a certain mass as halos, the progenitor is not guaranteed to be found if it has not assembled enough mass to be classified as a halo.
</p>

<p>
A halo from an earlier time is said to be <i>captured</i> by another halo, if most of its mass ends up in a satellite halo of the main descendent of that halo.
</p>
</div>
</div>

<div id="outline-container-org34c2155" class="outline-4">
<h4 id="org34c2155"><span class="section-number-4">6.1.2</span> <span class="todo TODO">TODO</span> Example</h4>
</div>
</div>

<div id="outline-container-org87de5c2" class="outline-3">
<h3 id="org87de5c2"><span class="section-number-3">6.2</span> Galaxy Merger Trees</h3>
<div class="outline-text-3" id="text-6-2">
</div>
<div id="outline-container-orgcf22613" class="outline-4">
<h4 id="orgcf22613"><span class="section-number-4">6.2.1</span> Implementation</h4>
<div class="outline-text-4" id="text-6-2-1">
<p>
<b>Output</b>
Create <i>stars<sub>snapnum</sub>.csv</i> for each snapshot
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">column</th>
<th scope="col" class="org-left">source</th>
<th scope="col" class="org-left">description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">snapnum</td>
<td class="org-left">-</td>
<td class="org-left">Integer</td>
</tr>

<tr>
<td class="org-left">starId</td>
<td class="org-left">HDF5</td>
<td class="org-left">PID for each star particle</td>
</tr>

<tr>
<td class="org-left">mass</td>
<td class="org-left">HDF5</td>
<td class="org-left">Mass at this snapshot</td>
</tr>

<tr>
<td class="org-left">galId</td>
<td class="org-left">grp</td>
<td class="org-left">galId at this snapshot</td>
</tr>

<tr>
<td class="org-left">haloId</td>
<td class="org-left">sogrp</td>
<td class="org-left">haloId at this snapshot</td>
</tr>

<tr>
<td class="org-left">mainId</td>
<td class="org-left">Derived</td>
<td class="org-left">The Unique galId for the simulation</td>
</tr>

<tr>
<td class="org-left">initId</td>
<td class="org-left">Derived</td>
<td class="org-left">First galId after the star formed</td>
</tr>
</tbody>
</table>

<p>
The mainId file:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">column</th>
<th scope="col" class="org-left">dtype</th>
<th scope="col" class="org-left">description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">mainId</td>
<td class="org-left">int64</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">snapnum</td>
<td class="org-left">int32</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">galId</td>
<td class="org-left">int32</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">hostId</td>
<td class="org-left">int32</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Mstar</td>
<td class="org-left">float32</td>
<td class="org-left">Stellar Mass</td>
</tr>

<tr>
<td class="org-left">Mtot</td>
<td class="org-left">float32</td>
<td class="org-left">Galaxy Mass</td>
</tr>

<tr>
<td class="org-left">Mhost</td>
<td class="org-left">float32</td>
<td class="org-left">Host Halo Mass</td>
</tr>

<tr>
<td class="org-left">mainIdNext</td>
<td class="org-left">int64</td>
<td class="org-left">The mainId of its descendent</td>
</tr>
</tbody>
</table>

<p>
<b>Find the parent and snaplast of a mainId</b>
First of all, maybe this information is redundant.
</p>

<p>
Create a temporary table: galId -&gt; galIdNext
</p>

<p>
MainId -&gt; galId 
       -&gt; galIdNext (Join, groupby and sortby sum(mass))
       -&gt; MainIdNext (Unique)
</p>

<p>
Last snapshot: stars having mainId
This snapshot: These stars having different mainId
</p>

<p>
Brute Force: 
</p>
<ul class="org-ul">
<li>Left join by starId to last snapshot, compare mainIdlast and mainId</li>
<li>Group by mainIdlast, pick the mainId as max(mass)
<ul class="org-ul">
<li>Expect in most cases mainIdlast == mainId</li>
</ul></li>
<li>Or. Group by galIdlast, find the galId in the next snapshot
<ul class="org-ul">
<li>galId uniquely determines mainId in the next snapshot</li>
</ul></li>
</ul>

<p>
Example:
snap i, mainId j: [[initId1], [InitId2], [InitIdj]]
</p>

<p>
<b>Relation between two galaxies at different time</b>
Task: Find the direct descendent of g0 at a later time t1.
</p>

<p>
Galaxy g0: (snapnum=t0, galId=0)
Galaxy g1: (snapnum=t1&gt;t0, galId=1)
</p>

<p>
At time t0, all stars in g0 has the same galId and mainId.
At time t1, they have different galId(t0) and mainId(t0), but supposedly most of them end up in a single galaxy g0'. 
If g0.mainId == g0'.mainId, R(g0, g0') = 'SELF'. 
If g0.mainId &lt;&gt; g0'.mainId, R(g0, g0') = 'MERGE'. 
</p>

<p>
Define R(g0, g1) according to the relation between g0 and g0''
g0'' at t0 is backtracked from g0':
</p>
<ul class="org-ul">
<li>g0''.mainId = g0'.mainId is found. 
<ul class="org-ul">
<li>R(g0, g1) = 'SELF' if g0''.mainId == g0.mainId</li>
<li>R(g0, g1) = 'SAT' if g0''.galId == g0.hostId</li>
<li>R(g0, g1) = 'CEN' if g0''.hostId == g0.galId</li>
<li>R(g0, g1) = 'SIB' if g0''.hostId == g0.hostId not in [g0''.galId, g0.galId]</li>
<li>Else: R(g0, g1) = 'NGB'</li>
</ul></li>
<li>Not found. R(g0, g1) = 'SELF'
Reason: Most g0 ends up in g0'. g0 formed even before the mainId of g0'. So even if g0'.mainId formed apart from g0, winds from g0 get back to g0's dscendent.</li>
</ul>

<p>
<b>Global variables</b>
maxMainId: Int. Counter for the global maximum mainId
spAll: DataFrame. All star particles.
</p>

<p>
<b>Procedure</b>
</p>
<ol class="org-ol">
<li>Generate <i>stars_$snapnum.csv</i> Table</li>
</ol>
<p>
<code>generate_star_history(model, start=0)</code>: Driver program. Start from earlier snapshot (start) and move forward in time. If start is not 0, read data from the last snapshot that has been processed.
</p>
<ul class="org-ul">
<li><code>process_snapshot(model, i)</code>: Update with the i-th snapshot.
<ul class="org-ul">
<li><code>load_snapshot(snapname, grpname)</code>: Load HDF5 and grp data
<ul class="org-ul">
<li><code>load_galaxies(fname, numPart)</code>: Load grp data.</li>
</ul></li>
<li><code>find_mainId_for_gals(spAll)</code>: Assign for each galaxy some mainId, if it is the mainId of most stars (by mass) in the galaxy.</li>
<li><code>update_mainId_of_stars(spAll, mainIds)</code>: Update mainId for each star as the mainId of its host galaxy at this snapshot.</li>
</ul></li>
</ul>
<ol class="org-ol">
<li>Generate <i>galmainid</i> Table</li>
</ol>
<p>
Pandas is likely sufficient for this task.
<code>galtree.py:build_mainId_table()</code>
</p>

<ol class="org-ol">
<li>Find the relations between two halos at different times</li>
</ol>
<p>
Method I. Find the most massive progenitor of any halo gal1 at z1 at z0 (z0 &gt; z1), gal1'. Define the relation between gal1 and any halo at z0 by the relations between gal1' and those halos (SELF, SIB, SAT, CEN, NGB). This method does not require the <b>mainId</b> information.
(galId, snapnum&lt;snapnum0) -&gt; (galId, hostId)
In total, ngals * (snapnum0-1) lines.
I can use dark matter to trace halos.
</p>

<p>
<b>Caveats</b>
</p>
<ul class="org-ul">
<li>Tidally stripped stars make up around 50% of the total stellar mass. Therefore, we need to make sure that:
<ul class="org-ul">
<li>Assign new mainId to a star only if it is in a SKID galaxy</li>
<li>Map mainId at any time only to SKID galaxy (galId != 0)</li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>


<div id="outline-container-org8c1e2a9" class="outline-2">
<h2 id="org8c1e2a9"><span class="section-number-2">7</span> Accretion Tracking Engine</h2>
<div class="outline-text-2" id="text-7">
<p>
<a id="orgf23a347"></a>
</p>

<p>
Analyzing the history of gas accretion into a galaxy is critical to understanding galaxy formation and evolution. The accretion tracking engine in PyGIZMO reconstructs the history of selected gas particles from a wide range of simulation outputs and classifies their accretion events into several categories that are physically motivated. The engine tracks selected gas particles across previous snapshots and analyzes their interactions with the galactic halos and wind particles over time.
</p>
</div>

<div id="outline-container-org5dcf19a" class="outline-3">
<h3 id="org5dcf19a"><span class="section-number-3">7.1</span> Basic Usage</h3>
<div class="outline-text-3" id="text-7-1">
<p>
The accretion.AccretionTracker class provides most of the public APIs for tracking accretion.
</p>

<p>
This following example creates a pandas DataFrame that tracks the accretion histories for all gas particles in the interstellar medium of a galaxy at z = 0.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #00ffff;">from</span> snapshot <span style="color: #00ffff;">import</span> Snapshot
<span style="color: #00ffff;">from</span> accretion <span style="color: #00ffff;">import</span> AccretionTracker

<span style="color: #ff4500;"># </span><span style="color: #ff4500;">Create an instance of the AccretionTracker from a snapshot (z=0)</span>
<span style="color: #eedd82;">model</span> = <span style="color: #ffa07a;">"l25n144-test"</span>    
<span style="color: #eedd82;">snap</span> = snapshot.Snapshot(model, 108)
<span style="color: #eedd82;">act</span> = AccretionTracker.from_snapshot(snap)

<span style="color: #ff4500;"># </span><span style="color: #ff4500;">Prepare all required permanent tables. Load if already existed, otherwise build new.</span>
act.initialize()

<span style="color: #ff4500;"># </span><span style="color: #ff4500;">Build temporary tables for selected particles from a galaxy specified by galIdTarget. Will take a while if the tables have not yet generated.</span>
act.build_temporary_tables_for_galaxy(galIdTarget)

<span style="color: #ff4500;"># </span><span style="color: #ff4500;">Run the engine and generate result</span>
<span style="color: #eedd82;">mwtable</span> = act.compute_wind_mass_partition_by_birthtag()
</pre>
</div>

<p>
The resulted table can be used to answer many questions. For example, to find the total amount of wind recycling divided into the different categories:
</p>
<div class="org-src-container">
<pre class="src src-python">mwtable.groupby(<span style="color: #ffa07a;">'birthTag'</span>)[<span style="color: #ffa07a;">'Mgain'</span>].<span style="color: #b0c4de;">sum</span>()
</pre>
</div>
</div>
</div>


<div id="outline-container-org490d1a0" class="outline-3">
<h3 id="org490d1a0"><span class="section-number-3">7.2</span> Algorithm</h3>
<div class="outline-text-3" id="text-7-2">
</div>
<div id="outline-container-org00592d6" class="outline-4">
<h4 id="org00592d6"><span class="section-number-4">7.2.1</span> Classification scheme</h4>
<div class="outline-text-4" id="text-7-2-1">
<p>
<a id="org575cb03"></a>
</p>


<div id="orgb1cf0bf" class="figure">
<p><img src="./figures/accretionengine.png" alt="accretionengine.png" />
</p>
<p><span class="figure-number">Figure 4: </span>Classification of Gas Accretion</p>
</div>

<p>
This following <a href="#orgb1cf0bf">diagram</a> demonstrates the algorithm for classifying gas particles according to their accretion history. In a typical scenario, one looks at all the gas particles (form a list of particle IDs, i.e., pidlist) that recently accreted into a galaxy (<i>target galaxy</i>) at some time, and classifies them into several accretion mode according their evolution histories at earlier times before accretion. PyGIZMO tracks each of the particle by their unique particle ID over previous snapshots and extracts key information that help classify the particle into one of the following <i>accretion modes</i>:
</p>

<ul class="org-ul">
<li><i>Merger</i>: The particle was found in another galaxy at some previous time (already accreted at least once prior to the current accretion event).</li>
<li><i>Primordial</i>: For first time accretion, the original component of a gas particle is classified as primordial accretion, which has two sub-categories
<ul class="org-ul">
<li><i>Cold accretion</i>: If the maximum temperature that the gas particle ever reached was below 10<sup>5.5</sup> K (controlled by (<code>logT_threshold</code>)).</li>
<li><i>Hot accretion</i>: If the maximum temperature was higher.</li>
</ul></li>
<li><i>Recycled</i>: For first time accretion, the mixed-in wind materials are treated separately from primordial accretion. The wind materials are further classifed according to the relation between the progenitor of the target galaxy <i>progenitor</i> and the galaxy where the winds originated from <i>birth site</i>. 
<ul class="org-ul">
<li><i>Recycled from self</i>: The wind materials originated directly from the direct prognitor of the target galaxy at some earlier time.</li>
<li><i>Recycled from central</i>: The birth site was the central galaxy of the progenitor.</li>
<li><i>Recycled from satellite</i>: The birth site was the satellite galaxy of the progenitor</li>
<li><i>Recycled from IGM</i>: The birth site and the progenitor were unrelated at the time of wind launch.</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org9c8b0d2" class="outline-4">
<h4 id="org9c8b0d2"><span class="section-number-4">7.2.2</span> Tracking wind component</h4>
<div class="outline-text-4" id="text-7-2-2">
<p>
<a id="orgaeb0dc9"></a>
</p>

<p>
More about tracking recycled materials: In a PhEW simulation, a normal gas particle may constantly get wind materials from different neighboring wind particles. Tracking every single mass flow between normal gas particles and wind particles and keeping track of where the wind particles came from will take too much disc space and is therefore impractical. Instead, we provide an approximate solution ('Bayesian machine' in the diagram) relying on computing the posterior probability of a gas particle getting materials from each of the recycled categories between two snapshots. See this <b>journal article</b> for details.
</p>
</div>
</div>


<div id="outline-container-orgc783b10" class="outline-4">
<h4 id="orgc783b10"><span class="section-number-4">7.2.3</span> Particle splitting</h4>
<div class="outline-text-4" id="text-7-2-3">
<p>
<a id="org366c379"></a>
</p>

<p>
In later version of the PhEW, a gas particle splits into two halves when its mass grows to over 3 times its original mass. One of the newly spawned particle will inherit the particle ID while the other one will have a new unique ID. The simulation outputs each of the splitting event into a log files like "split.snapnum". The problem is, how to reconstruct the split history of any given gas particle from these files?
</p>

<p>
<a id="org32df7d8"></a>
<b>Definition of <i>generation</i></b>: Tracing back in time and starting from 0, the <i>generation</i> of the particle increases by 1 every time when it splitted in the past. If the particle was spawned at some earlier time from a parent, the <i>generation</i> will keep increasing for the parent. 
</p>

<p>
The following example tracks the <i>generation</i> of a particle with PId = 3, which was spawned from another particle with PId = 12, which was then spawned from PId = 15. The particle splitted at snapnum = 106 and snapnum = 103.
</p>

<pre class="example">
snapnum:     108 107 106 105 104 103 102 101 100 099 098
ParticleID:  3   3   3   3   3   3   12  12  12  12  15 
Split                X           X   X       X       X
generation:  0   0   1   1   1   2   3   3   4   5   6
</pre>

<p>
The particle was at generation = 6 at snapnum = 98. Therefore we assume that only 1/32 (2<sup>-gen</sup>) of the mass of particle PId = 15 ended up in particle PId = 3 at snapnum = 108.
</p>

<p>
Firstly, a permanent table, <i>splittable</i>, is built for each simulation (<code>Simulation.build_splittable()</code>). Each entry corresponds to a split event and keeps the newly spawned particle ID (PId), the ID of the particle that splitted (parentId), the next snapnum after the split (snapnext) and the generation of the <b>splitting</b> particle at this particular splitting event (parentGen).
</p>

<p>
Then, for a selection of particles, a temporary table, <i>ancestors</i>, which basically reconstructs the above diagram, is built with
<code>AccretionTracker._find_particle_ancestors(splittable, pidlist)</code>
</p>

<p>
In each snapshot, <code>AccretionTracker.build_gptable()</code> loads all particles in the pidlist as well as their parents at that snapshot. The mass of each particle is reduced to match the generation number. For example, using the diagram above, at snapnum = 102, particle(3) did not exist yet, so the program looks for its parent particle(12) and reduce its mass to 1/8.
</p>

<p>
At any time, one particle could be the parent of multiple particles from later time. In these cases, information of the parent particle is copied multiple times for each of its descendents. However, the generation number for these descendents may not be the same. For example, the following diagram demonstrates the history of particle(4):
</p>

<pre class="example">
snapnum:     108 107 106 105 104 103 102 101 100 099 098
ParticleID:  4   4   4   4   4   4   4   4   12  12  15 
Split                                X       X       X
generation:  0   0   0   0   0   0   1   1   2   2   3
</pre>

<p>
In the end, the final <i>gptable</i> should contain len(pidlist) unique PIds, each having one entry for each snapshot.
</p>
</div>
</div>
</div>


<div id="outline-container-org429b6ca" class="outline-3">
<h3 id="org429b6ca"><span class="section-number-3">7.3</span> Implementation</h3>
<div class="outline-text-3" id="text-7-3">
<p>
The accretion tracking engine relies on a set of permanent tables that need to be computed once for each simulation and a set of temporary tables that need to be constructed each time when one selects a new target halo from a snapshot. The following diagram demonstrates the workflow.
</p>


<div id="orgbd04a84" class="figure">
<p><img src="./figures/workflow.png" alt="workflow.png" />
</p>
<p><span class="figure-number">Figure 5: </span>Workflow of the Wind Tracking Engine</p>
</div>
</div>

<div id="outline-container-orga9bdbed" class="outline-4">
<h4 id="orga9bdbed"><span class="section-number-4">7.3.1</span> Data structures and schema</h4>
<div class="outline-text-4" id="text-7-3-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 1:</span> A list of Tables</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Table</th>
<th scope="col" class="org-left">Format</th>
<th scope="col" class="org-left">Path</th>
<th scope="col" class="org-left">Sources</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">inittable</td>
<td class="org-left">CSV</td>
<td class="org-left">$DATA</td>
<td class="org-left">snapshot, initwinds, rejoin</td>
<td class="org-left">Wind events (launch/rejoin)</td>
</tr>

<tr>
<td class="org-left">phewtable</td>
<td class="org-left">parquet</td>
<td class="org-left">$DATA</td>
<td class="org-left">snapshot, inittable, halos</td>
<td class="org-left">PhEW particles</td>
</tr>

<tr>
<td class="org-left">progtable</td>
<td class="org-left">CSV</td>
<td class="org-left">$WORK</td>
<td class="org-left">snapshot, halos</td>
<td class="org-left">Halo progenitors at earlier times</td>
</tr>

<tr>
<td class="org-left">hostmap</td>
<td class="org-left">CSV</td>
<td class="org-left">$WORK</td>
<td class="org-left">halos</td>
<td class="org-left">The host for each halo</td>
</tr>

<tr>
<td class="org-left">splittable</td>
<td class="org-left">CSV</td>
<td class="org-left">$WORK</td>
<td class="org-left">split</td>
<td class="org-left">Particle splitting event</td>
</tr>

<tr>
<td class="org-left">gptable</td>
<td class="org-left">parquet</td>
<td class="org-left">$TMP</td>
<td class="org-left">snapshot, halos</td>
<td class="org-left">History of gas particles from the target</td>
</tr>

<tr>
<td class="org-left">pptable</td>
<td class="org-left">parquet</td>
<td class="org-left">$TMP</td>
<td class="org-left">snapshot, phewtable</td>
<td class="org-left">History of relevant PhEW particles</td>
</tr>

<tr>
<td class="org-left">halotable</td>
<td class="org-left">CSV</td>
<td class="org-left">$TMP</td>
<td class="org-left">gptable, pptable, halos</td>
<td class="org-left">Relevant Halos</td>
</tr>
</tbody>
</table>

<p>
Notes: 
</p>
<ul class="org-ul">
<li>The source column indicates the raw data from which the table is built.</li>
<li>Default paths are defined in the configuration file.</li>
</ul>

<p>
<b>Permanent tables</b>
The <i>phewtable</i> parquet table (<code>Simulation.build_phewtable</code>)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 2:</span> phewtable</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Field</th>
<th scope="col" class="org-left">dtype</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">PId*</td>
<td class="org-left">int64</td>
<td class="org-left">Unique particle ID of a wind(PhEW) particle</td>
</tr>

<tr>
<td class="org-left">snapnum</td>
<td class="org-left">int32</td>
<td class="org-left">Id of any snapshot in which PId is a wind</td>
</tr>

<tr>
<td class="org-left">Mass</td>
<td class="org-left">float64</td>
<td class="org-left">Mass of the particle at snapnum</td>
</tr>

<tr>
<td class="org-left">haloId</td>
<td class="org-left">int32</td>
<td class="org-left">haloId of the particle at snapnum</td>
</tr>

<tr>
<td class="org-left">(Mloss)</td>
<td class="org-left">float64</td>
<td class="org-left">Mass loss since the previous snapshot</td>
</tr>

<tr>
<td class="org-left">(birthId)</td>
<td class="org-left">int32</td>
<td class="org-left">The birthplace of the PhEW particle</td>
</tr>
</tbody>
</table>

<p>
It's a gigantic table that needs to be frequently queried. It contains the attributes, such as mass and haloId, of all PhEW particles in any snapshot. The Mloss field is derived for each particle (PId) over time. Assume at each snapshot, a total mass of Mloss was lost from the PhEW particle (PId) to the halo (haloId) where it was found at that snapshot.
</p>

<p>
The <i>inittable</i> CSV table (<code>Simulation.build_inittable()</code>)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 3:</span> inittable</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Field</th>
<th scope="col" class="org-left">dtype</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">PId*</td>
<td class="org-left">int64</td>
<td class="org-left">Unique particle ID of a wind(PhEW) particle</td>
</tr>

<tr>
<td class="org-left">snapfirst</td>
<td class="org-left">int32</td>
<td class="org-left">The snapshot before becoming winds</td>
</tr>

<tr>
<td class="org-left">minit</td>
<td class="org-left">float64</td>
<td class="org-left">Initial mass</td>
</tr>

<tr>
<td class="org-left">birthId</td>
<td class="org-left">int32</td>
<td class="org-left">haloId of the halo in snapfirst</td>
</tr>

<tr>
<td class="org-left">snaplast</td>
<td class="org-left">int32</td>
<td class="org-left">The last snapshot</td>
</tr>

<tr>
<td class="org-left">mlast</td>
<td class="org-left">float64</td>
<td class="org-left">Mass when the particle appeared the last time</td>
</tr>
</tbody>
</table>

<p>
This table keeps records of all wind events in a simulation, such as when and where a wind particle was launched, the last time a wind particle appeared before fully evaporated, the mass of a wind particle at birth and death.
</p>

<p>
The <i>progtable</i> CSV table (<code>Snapshot.build_progtable()</code>)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 4:</span> progtable</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Field</th>
<th scope="col" class="org-left">dtype</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">haloId*</td>
<td class="org-left">int32</td>
<td class="org-left">Unique haloId in the single snapshot</td>
</tr>

<tr>
<td class="org-left">snapnum</td>
<td class="org-left">int32</td>
<td class="org-left">Id of any previous snapshot</td>
</tr>

<tr>
<td class="org-left">progId</td>
<td class="org-left">int32</td>
<td class="org-left">haloId of the progenitor in snapnum</td>
</tr>

<tr>
<td class="org-left">hostId</td>
<td class="org-left">int32</td>
<td class="org-left">haloId of the host halo of the progenitor</td>
</tr>

<tr>
<td class="org-left">logMvir</td>
<td class="org-left">float32</td>
<td class="org-left">Virial mass of the progentor</td>
</tr>

<tr>
<td class="org-left">logMsub</td>
<td class="org-left">float32</td>
<td class="org-left">Total mass of the host</td>
</tr>
</tbody>
</table>

<p>
This table defines the prognitor of any halo from a snapshot in the previous snapshot. Recursively quering the table finds all previous progenitors of any given halo. We use this table to define the relation between any halo at a given snapshot and any halo in a previous snapshot, using <code>progen.get_relationship_between_halos()</code>
</p>

<p>
The <i>hostmap</i> CSV table (<code>Simulation.build_hostmap()</code>)
</p>

<p>
This maps (snapnum, haloId) to hostId, the host galaxy/halo of the haloId at snapnum.
</p>

<p>
The <i>splittable</i> CSV table (<code>Simulation.build_splittable()</code>)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 5:</span> splittable</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Field</th>
<th scope="col" class="org-left">dtype</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">PId*</td>
<td class="org-left">int64</td>
<td class="org-left">Unique particle ID</td>
</tr>

<tr>
<td class="org-left">parentId</td>
<td class="org-left">int64</td>
<td class="org-left">The ID of its parent from whom it was split</td>
</tr>

<tr>
<td class="org-left">Mass</td>
<td class="org-left">float64</td>
<td class="org-left">The mass of the parent before splitting</td>
</tr>

<tr>
<td class="org-left">atime</td>
<td class="org-left">float32</td>
<td class="org-left">Time of splitting</td>
</tr>

<tr>
<td class="org-left">snapnext</td>
<td class="org-left">int32</td>
<td class="org-left">Next snapshot since splitting</td>
</tr>

<tr>
<td class="org-left">gen</td>
<td class="org-left">int32</td>
<td class="org-left">The generation at the current time</td>
</tr>
</tbody>
</table>

<p>
<b>Temporary tables</b>
The temporary <i>gptable</i> Parquet table (<code>AccretionTracker.build_gptable()</code>)
</p>

<table id="orge79a28f" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 6:</span> gptable</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Field</th>
<th scope="col" class="org-left">dtype</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">PId*</td>
<td class="org-left">int64</td>
<td class="org-left">Unique particle ID of a gas particle</td>
</tr>

<tr>
<td class="org-left">snapnum</td>
<td class="org-left">int32</td>
<td class="org-left">Id of any previous snapshot</td>
</tr>

<tr>
<td class="org-left">Mass</td>
<td class="org-left">float64</td>
<td class="org-left">Mass of the gas particle at snapnum</td>
</tr>

<tr>
<td class="org-left">haloId</td>
<td class="org-left">int32</td>
<td class="org-left">haloId of the particle at snapnum</td>
</tr>

<tr>
<td class="org-left">(Mgain)</td>
<td class="org-left">float64</td>
<td class="org-left">Total mass gained since the previous snapshot</td>
</tr>
</tbody>
</table>

<p>
It tracks the locations and properties of all selected gas particles (e.g., from a single galaxy at some time) in all the previous snapshots since the beginning of the simulation.
</p>

<p>
If the gas particle did not exist at any snapshot, find its parent at that snapshot (defined in the <i>splittable</i>).
</p>

<p>
If the particle has splitted before, reduce the Mass be a factor of 2<sup>-gen</sup>, where 'gen' is the <a href="#org32df7d8">generation number</a> of the particle.
</p>

<p>
Finally, a 'Mgain' field is computed as the total mass that the particle gained since the last snapshot, using a window function on each PId.
<code>AccretionTracker.compute_mgain_partition_by_Pid(gptable)</code>
</p>

<p>
The newly generated table is saved as <code>gptable_{:03d}_{:05d}.parquet</code>, where ':03d', ':05d' are snapnum and galIdTarget, respectively.
</p>

<ol class="org-ol">
<li>The temporary <i>pptable</i> Parquet table (<code>AccretionTracker.build_pptable(inittable, phewtable)</code>)</li>
</ol>

<table id="org3a1dfdf" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 7:</span> pptable</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Field</th>
<th scope="col" class="org-left">dtype</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">PId*</td>
<td class="org-left">int64</td>
<td class="org-left">Unique particle ID of a wind(PhEW) particle</td>
</tr>

<tr>
<td class="org-left">snapnum</td>
<td class="org-left">int32</td>
<td class="org-left">Id of a snapshot</td>
</tr>

<tr>
<td class="org-left">haloId</td>
<td class="org-left">int32</td>
<td class="org-left">haloId of the particle at snapnum</td>
</tr>

<tr>
<td class="org-left">Mass</td>
<td class="org-left">float64</td>
<td class="org-left">Mass of the particle at snapnum</td>
</tr>

<tr>
<td class="org-left">(Mloss)</td>
<td class="org-left">float64</td>
<td class="org-left">Mass loss since the previous snapshot</td>
</tr>

<tr>
<td class="org-left">snapfirst</td>
<td class="org-left">int32</td>
<td class="org-left">The first snapshot</td>
</tr>

<tr>
<td class="org-left">birthId</td>
<td class="org-left">int32</td>
<td class="org-left">haloId of where it is born</td>
</tr>

<tr>
<td class="org-left">(birthTag)</td>
<td class="org-left">str</td>
<td class="org-left">Relationship tag of its birth halo</td>
</tr>
</tbody>
</table>

<p>
A subset of the gigantic <i>phewtable</i> with a selection of PhEW particles. A PhEW particle is selected if it ever appeared in any of the halos in the <i>gptable</i>. The table should contain a complete record for each selected PhEW particle, i.e., any snapshot in which the particle existed.
</p>

<p>
The 'Mloss' field is computed as the total mass that the particle lost since the last snapshot, using a window function on each PId.
</p>

<p>
For each PhEW particle, a birthId indicating its birth galaxy, is found from the <i>inittable</i>.
</p>

<p>
Finally, a birthTag is generated that defines the relationship between the birth galaxy and the target galaxy. This is done with:
<code>AccretionTracker.define_halo_relationship(progId,progHost,haloId,hostId)</code>
</p>

<p>
The newly generated table is saved as <code>pptable_{:03d}_{:05d}.parquet</code>, where ':03d', ':05d' are snapnum and galIdTarget, respectively.
</p>
</div>
</div>

<div id="outline-container-orgf617e6b" class="outline-4">
<h4 id="orgf617e6b"><span class="section-number-4">7.3.2</span> Procedure</h4>
<div class="outline-text-4" id="text-7-3-2">
</div>
<ol class="org-ol">
<li><a id="orgde185d2"></a>Selecting particles<br />
<div class="outline-text-5" id="text-7-3-2-1">
<p>
Select the particles that we want to track. The list of their particle IDs (pidlist) is an input to the AccretionTracker. Depending on the user case, the particles could be:
</p>
<ul class="org-ul">
<li>Recently accreted particles on a galaxy.
API: <code>pidlist = Snapshot.get_recent_accretion(galIdTarget)</code> (TODO)</li>
<li>Current ISM particles within a galaxy(galIdTarget)
API: <code>pidlist = Snapshot.get_gas_particles_in_galaxy(galIdTarget)</code></li>
</ul>

<p>
Note that, if the particles do not come from a same galaxy, one needs to get a list of all of their host galaxies and build the temporary tables for every single galaxy individually. 
</p>
</div>
</li>

<li><a id="org70ff52e"></a>Build/Load permanent tables<br />
<div class="outline-text-5" id="text-7-3-2-2">
<p>
<code>AccretionTracker.initialize()</code>
</p>
</div>
</li>

<li><a id="org7b839ee"></a>Build temporary tables for any galaxy(galIdTarget)<br />
<div class="outline-text-5" id="text-7-3-2-3">
<p>
<code>AccretionTracker.build_temporary_tables_for_galaxy(galIdTarget)</code>
</p>
<ol class="org-ol">
<li>Build the <a href="#org366c379">splitting histories</a> of each particle in the <i>pidlist</i>.
<ul class="org-ul">
<li><code>AccretionTracker._find_particle_ancestors(splittable, pidlist)</code></li>
<li>This creates a temporary table <code>AccretionTracker._ancestors</code></li>
</ul></li>
<li>Build the <a href="#orge79a28f">gptable</a>.
<ul class="org-ul">
<li><code>AccretionTracker.build_gptable(pidlist)</code></li>
<li>Load gas particles (or their parents) from each snapshot</li>
<li>Compute the total mass they gained between two snapshots</li>
</ul></li>
<li>Build the <a href="#org3a1dfdf">pptable</a>.
<ul class="org-ul">
<li><code>AccretionTracker.build_pptable(inittable, phewtable)</code></li>
<li>Select all PhEW particles that potentially interacted with the particles in the <i>pidlist</i>, from the <i>phewtable</i>.</li>
<li>Find the birth galaxy for each PhEW particle using information from the <i>inittable</i>.</li>
<li>Compute the mass loss of each PhEW particle between any two consecutive snapshots.</li>
<li>Add a birthTag to each PhEW particle that defines the relation between its birth galaxy and the target galaxy(galIdTarget). This operation needs <i>gptable</i>, <i>progtable</i> and <i>hostmap</i>.</li>
</ul></li>
</ol>
</div>
</li>

<li><a id="org6c8ffd3"></a>Classify and accumulate wind materials over time<br />
<div class="outline-text-5" id="text-7-3-2-4">
<p>
<code>AccretionTracker.compuate_wind_mass_partition_by_birthTag()</code>
</p>

<p>
The algorithm is <a href="#orgaeb0dc9">here</a>. For the purpose of description here, assume all wind materials lost from the PhEW particles are deposited uniformly in the halo (the prior is unity).
</p>

<p>
For each snapshot:
</p>
<ol class="org-ol">
<li>Compute the total amount of wind materials deposited into each halo by PhEW particles since the last snapshot.</li>
<li>Divide the amount into <a href="#org575cb03">categories</a> according to the birthTag of the PhEW particle.</li>
<li>Find for each halo, the gas particles that it hosted at that snapshot.</li>
<li>Compute the wind materials that those gas particles gained since the last snapshot, by category.</li>
<li>Accumulate over time for each gas particle.</li>
</ol>
</div>
</li>
</ol>
</div>
</div>
</div>


<div id="outline-container-org90171a9" class="outline-2">
<h2 id="org90171a9"><span class="section-number-2">8</span> Quasar Absorption Line Spectra</h2>
<div class="outline-text-2" id="text-8">
<p>
Future work.
</p>
</div>
</div>

<div id="outline-container-org722f823" class="outline-2">
<h2 id="org722f823"><span class="section-number-2">9</span> <span class="todo TODO">TODO</span> Scalable Data Pipelines with Apache Spark</h2>
</div>


<div id="outline-container-org2ef296f" class="outline-2">
<h2 id="org2ef296f"><span class="section-number-2">10</span> References</h2>
<div class="outline-text-2" id="text-10">
<p>
<a href="http://www.tapir.caltech.edu/~phopkins/Site/GIZMO.html">The GIZMO Simulation Code</a>
</p>

<p>
<a href="https://arxiv.org/abs/2005.13585">The Physically Evolved Winds (PhEW) Model, Journal Article, I. Model</a>
</p>

<p>
<a href="https://arxiv.org/abs/2106.01511">The Physically Evolved Winds (PhEW) Model, Journal Article, II. Implementation</a>
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2021-07-01 Thu 00:00</p>
<p class="author">Author: Shuiyao (Charlie) Huang</p>
<p class="date">Created: 2021-07-07 Wed 14:29</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
